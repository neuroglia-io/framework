@using Microsoft.AspNetCore.Components.Web
@inject IDagreService DagreService
@inject IJSRuntime JSRuntime
@implements IDisposable

@if (Graph != null) {
    <div class="graph-container">
        <CascadingValue Value="Graph">
            <svg @ref="graphReference"
                class="graph-canvas @Graph.CssClass"
                width="@(Graph.Width?.ToString() ?? "100%")" 
                height="@(Graph.Height?.ToString() ?? "100%")"
                @onmouseenter="HandleOnMouseEnter"
                @onmouseleave="HandleOnMouseLeave"
                @onmousedown="HandleOnMouseDown"
                @onmouseup="HandleOnMouseUp"
                @onmousemove="HandleOnMouseMove"
                @onwheel="HandleOnWheel"
            >
                <defs>
                    @foreach(var def in Graph.SvgDefinitionComponents)
                    {
                        <DynamicComponent @key="def" Type="def" />
                    }
                </defs>
                <g 
                    class="graph"
                    transform="scale(@(Graph.Scale.ToInvariantString())) translate(@Graph.X.ToInvariantString(), @Graph.Y.ToInvariantString())"
                >
                    <g class="clusters">
                        @foreach(var cluster in Graph.AllClusters.Values)
                        {
                            @if (cluster != null)
                            {
                                <InteractiveDynamicComponent @key="cluster" Type="Graph.GetComponentTypeAsync(cluster)" Parameters="GetComponentParameter(cluster)" />
                            }
                        }
                    </g>
                    <g class="edges">
                        @foreach(var edge in Graph.Edges.Values)
                        {
                            @if (edge != null)
                            {
                                <DynamicComponent @key="edge" Type="Graph.GetComponentTypeAsync(edge)" Parameters="GetComponentParameter(edge)" />
                            }
                        }
                    </g>
                    <g class="nodes">
                        @foreach(var node in Graph.AllNodes.Values)
                        {
                            @if (node != null)
                            {
                                <InteractiveDynamicComponent @key="node" Type="Graph.GetComponentTypeAsync(node)" Parameters="GetComponentParameter(node)" />
                            }
                        }
                    </g>
                </g>
            </svg>
        </CascadingValue>
        <div class="graph-controls">
            <button class="btn btn-outline-dark" type="button" @onclick="Center" title="center graph">
                <span class="oi oi-target"></span>
            </button>
            <button class="btn btn-outline-dark" type="button" @onclick="ZoomToFit" title="zoom to fit">
                <span class="oi oi-resize-both"></span>
            </button>
        </div>
    </div>
}

@code {
    [Parameter] public IDagreGraphOptions? Options { get; set; }

    [Parameter] public IGraphViewModel? Graph { get; set; }

    [Parameter] public EventCallback<GraphEventArgs<MouseEventArgs>> OnMouseEnter { get; set; }

    [Parameter] public EventCallback<GraphEventArgs<MouseEventArgs>> OnMouseLeave { get; set; }

    [Parameter] public EventCallback<GraphEventArgs<MouseEventArgs>> OnMouseDown { get; set; }

    [Parameter] public EventCallback<GraphEventArgs<MouseEventArgs>> OnMouseUp { get; set; }

    [Parameter] public EventCallback<GraphEventArgs<MouseEventArgs>> OnMouseMove { get; set; }

    [Parameter] public EventCallback<GraphEventArgs<WheelEventArgs>> OnWheel { get; set; }

    protected ElementReference graphReference;

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        if (this.Graph != null)
        {
            this.RemoveHandlers();
            this.Graph.MouseEnter += this.InvokeMouseEnter;
            this.Graph.MouseLeave += this.InvokeMouseLeave;
            this.Graph.MouseDown += this.InvokeMouseDown;
            this.Graph.MouseUp += this.InvokeMouseUp;
            this.Graph.MouseMove += this.InvokeMouseMove;
            this.Graph.Wheel += this.InvokeWheel;
            //this.Graph.ShowConstruction = true;
            await this.RefreshAsync();
            //Console.WriteLine(await this.DagreService.SerializeAsync(this.Graph.DagreGraph!));
            //Console.WriteLine(Newtonsoft.Json.JsonConvert.SerializeObject(this.Graph));
        }
    }

    protected async Task InvokeMouseEnter(GraphEventArgs<MouseEventArgs> e)
    {
        await this.OnMouseEnter.InvokeAsync(e);
    }

    protected async Task InvokeMouseLeave(GraphEventArgs<MouseEventArgs> e)
    {
        await this.OnMouseLeave.InvokeAsync(e);
    }

    protected async Task InvokeMouseDown(GraphEventArgs<MouseEventArgs> e)
    {
        await this.OnMouseDown.InvokeAsync(e);
    }

    protected async Task InvokeMouseUp(GraphEventArgs<MouseEventArgs> e)
    {
        await this.OnMouseUp.InvokeAsync(e);
    }

    protected async Task InvokeMouseMove(GraphEventArgs<MouseEventArgs> e)
    {
        await this.OnMouseMove.InvokeAsync(e);
    }

    protected async Task InvokeWheel(GraphEventArgs<WheelEventArgs> e)
    {
        await this.OnWheel.InvokeAsync(e);
    }

    protected virtual void RemoveHandlers()
    {
        if (this.Graph != null)
        {
            this.Graph.MouseEnter -= this.InvokeMouseEnter;
            this.Graph.MouseLeave -= this.InvokeMouseLeave;
            this.Graph.MouseDown -= this.InvokeMouseDown;
            this.Graph.MouseUp -= this.InvokeMouseUp;
            this.Graph.MouseMove -= this.InvokeMouseMove;
            this.Graph.Wheel -= this.InvokeWheel;
        }
    }

    public virtual async Task RefreshAsync()
    {
        if (this.Graph != null)
        {
            await this.DagreService.ComputePositionsAsync(this.Graph, this.Options);
            this.StateHasChanged();
            await this.ZoomToFit();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
            await this.JSRuntime.InvokeVoidAsync("neuroglia.blazor.preventScroll", this.graphReference);
    }

    protected virtual async Task Center()
    {
        if (this.Graph == null) 
            return;
        var position = await this.JSRuntime.InvokeAsync<BoundingBox>("neuroglia.blazor.getCenter", this.graphReference);
        this.Graph.X = position.X / (double)this.Graph.Scale;
        this.Graph.Y = position.Y / (double)this.Graph.Scale;
    }

    protected virtual async Task ZoomToFit()
    {
        if (this.Graph == null) 
            return;
        this.Graph.Scale = Math.Clamp(await this.JSRuntime.InvokeAsync<decimal>("neuroglia.blazor.getScale", this.graphReference), Constants.MinScale, Constants.MaxScale);
        this.StateHasChanged();
        await this.Center();
    }

    protected virtual Dictionary<string, object> GetComponentParameter(IGraphElement element)
    {
        var parameters = new Dictionary<string, object>()
        {
            { "Element", element }
        };
        return parameters;
    }

    protected virtual async Task HandleOnMouseEnter(MouseEventArgs e)
    {
        if (this.Graph != null)
            await this.Graph.OnMouseEnterAsync(this.graphReference, e, null);
    }

    protected virtual async Task HandleOnMouseLeave(MouseEventArgs e)
    {
        if (this.Graph != null)
            await this.Graph.OnMouseLeaveAsync(this.graphReference, e, null);
    }

    protected virtual async Task HandleOnMouseDown(MouseEventArgs e)
    {
        if (this.Graph != null)
            await this.Graph.OnMouseDownAsync(this.graphReference, e, null);
    }

    protected virtual async Task HandleOnMouseMove(MouseEventArgs e)
    {
        if (this.Graph != null)
            await this.Graph.OnMouseMoveAsync(this.graphReference, e, null);
    }

    protected virtual async Task HandleOnMouseUp(MouseEventArgs e)
    {
        if (this.Graph != null)
            await this.Graph.OnMouseUpAsync(this.graphReference, e, null);
    }

    protected virtual async Task HandleOnWheel(WheelEventArgs e)
    {
        if (this.Graph != null)
            await this.Graph.OnWheelAsync(this.graphReference, e, null);
    }

    private bool disposed;
    protected virtual void Dispose(bool disposing)
    {
        if (!this.disposed)
        {
            this.RemoveHandlers();
            this.disposed = true;
        }
    }

    public void Dispose()
    {
        this.Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }
}